# lanFileSharer

一个用于在局域网设备间直接共享文件的工具，具备全面的传输状态管理和实时进度跟踪功能。

## 工作原理

连接过程设计为健壮且高效，结合了直接 IP 通信和 mDNS 主机名解析的灵活性。它分为两个主要阶段：

### 阶段 1：发现和初始握手(DNS-SD + HTTP)

1.  **服务发现**：当接收端应用启动时，它会通过 mDNS/DNS-SD 在局域网广播其存在。
2.  **IP 解析**：发送端应用通过此广播发现接收端，并将其`.local`主机名解析为具体 IP 地址(如`192.168.1.55`)。
3.  **HTTP 握手**：发送端随后使用发现的 IP 地址与接收端建立直接 HTTP 连接。此连接用作主要信令通道，用于交换基本元数据，如要传输的文件结构和初始 WebRTC 会话信息(SDP Offer/Answer)。

### 阶段 2：高速数据传输(WebRTC)

1.  **PeerConnection 建立**：握手完成后，双方设备继续建立 WebRTC `PeerConnection`。
2.  **P2P 传输**：此连接用于实际高速、点对点的文件数据传输，利用 WebRTC 数据通道的性能。

### 通过`SetMulticastDNSMode`实现的健壮性

为了使连接过程对 IP 地址变更(如 DHCP 租约更新)具有弹性，底层 WebRTC `SettingEngine`配置了`MulticastDNSModeEnabled`。

- **功能**：此设置使 WebRTC 中的 ICE 代理能够在连接检查阶段直接解析`.local`主机名。
- **重要性**：虽然初始连接使用预解析的 IP，但 ICE 协商包含带有`.local`主机名的候选。如果初始 IP 已失效，ICE 代理可以使用 mDNS 重新解析主机名为设备当前 IP 地址。这作为一个强大的回退机制，确保仍能建立连接，使应用显著更健壮。

这种双重方法利用直接 IP 通信的速度进行初始握手，同时保留 mDNS 的灵活性和弹性用于底层 P2P 数据连接。

## 传输管理架构

应用程序具有统一的传输管理系统，提供实时状态跟踪和会话管理：

### 核心组件

- **UnifiedTransferManager（统一传输管理器）**：管理文件队列、分块器，并与会话状态跟踪协调
- **TransferStatusManager（传输状态管理器）**：处理会话级状态跟踪，支持单会话传输
- **SessionTransferStatus（会话传输状态）**：跟踪整体会话进度和当前文件传输状态
- **TransferStatus（传输状态）**：单个文件传输的详细状态信息

### 主要特性

- **实时进度跟踪**：监控传输进度，包括已发送字节数、传输速率和预计完成时间
- **会话管理**：针对典型使用场景优化的单会话架构
- **事件系统**：状态变化和传输事件的实时通知
- **错误处理**：全面的错误处理，包括重试机制和故障恢复
- **状态管理**：支持暂停/恢复操作和传输生命周期管理

## 架构重构总结

传输管理系统经过重大重构，提供了更清洁、更易维护的架构：

### 🎯 **重构前后对比**

| 方面           | 重构前（旧架构）                                                                   | 重构后（新架构）                |
| -------------- | ---------------------------------------------------------------------------------- | ------------------------------- |
| **管理器数量** | 3 个独立管理器（FileTransferManager、FileStructureManager、TransferStatusManager） | 1 个统一管理器 + 1 个状态管理器 |
| **文件数量**   | 20+个文件，功能重叠                                                                | 12 个核心文件，职责清晰         |
| **会话模型**   | 多会话复杂性                                                                       | 单会话优化                      |
| **API 复杂度** | 多个不同模式的 API                                                                 | 统一、一致的 API                |
| **状态跟踪**   | 每文件状态管理                                                                     | 会话级别 + 当前文件跟踪         |
| **内存使用**   | 重复的数据结构                                                                     | 优化的单一结构                  |

### 🏗️ **新架构优势**

#### **1. 简化设计**

- **单会话专注**：针对传输文件的常见用例进行优化
- **顺序处理**：会话内文件逐个处理
- **统一 API**：所有传输操作通过一致的接口

#### **2. 更好性能**

- **减少内存开销**：消除重复数据结构
- **高效状态更新**：会话级跟踪 + 当前文件详情
- **简化事件**：直接方法通知，而非复杂事件对象

#### **3. 改进可维护性**

- **清晰职责分离**：UnifiedTransferManager 处理文件/队列，TransferStatusManager 处理状态
- **一致错误处理**：所有组件统一的错误处理模式
- **简化测试**：更少组件，职责更清晰

#### **4. 业务逻辑对齐**

- **真实使用场景**：匹配用户实际传输文件的方式（一次一个会话）
- **简化队列管理**：待处理 → 活跃 → 完成/失败 流程
- **直观状态模型**：整体会话进度 + 当前文件详情

### 📊 **迁移影响**

重构在提供这些改进的同时保持了向后兼容性：

```go
// 简单、统一的API
manager := transfer.NewUnifiedTransferManager("session-id")

// 向会话添加文件
manager.AddFile(fileNode)

// 监控会话进度
sessionStatus := manager.GetSessionStatus()
fmt.Printf("会话: %.1f%% (%d/%d 文件)",
    sessionStatus.OverallProgress,
    sessionStatus.CompletedFiles,
    sessionStatus.TotalFiles)

// 监控当前文件
if sessionStatus.CurrentFile != nil {
    fmt.Printf("当前: %s (%.1f%%)",
        sessionStatus.CurrentFile.FilePath,
        sessionStatus.CurrentFile.GetProgressPercentage())
}
```

### 🔧 **技术改进**

- **线程安全**：所有组件都是线程安全的，使用适当的互斥锁
- **事件系统**：异步、非阻塞的事件传递
- **错误恢复**：全面的错误处理和重试机制
- **配置管理**：所有组件的统一配置系统
- **测试覆盖**：所有新组件的全面测试覆盖
